<div id="section-0"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>We’ve successfully created our first extension, but it doesn’t really do much yet. We aren’t taking advantage of the Associative Model. In order to do that, we need to hook dynamic data into our extension. Before we do that though, let’s review the lifecycle of an extension.</br></br></br></p><h2>The Lifecycle of an Extension</h2><p>As we saw in the previous chapter, a Qlik Sense extension is built off of several components of code. When exactly do all of these functions get triggered though? Let’s examine.</p><p>There are three events that happen in the life of an extension that involve our code:</p><ol><li><p>Creating the extension</p></li><li><p>Painting the extension</p></li><li><p>Resizing the extension</p></li></ol></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div><div id="section-1"class="section lifecycle-of-extension"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p><strong>1. Creating an Extension</strong></p><p>When we drag our extension onto a dashboard to create a new instance of it, Qlik Sense runs our <em>my-table.js</em> file to define the extension object. It will run all of the code in that file just once and return the JSON object defining our extension. A GenericObject is created for the extension based on our initialProperties parameter. Our definition parameter is used to define our properties panel. And our paint and resize functions are ready to be called when its time to render the extension. The extension will also be created every time we open or refresh the sheet it is on.</p><p><strong>2. Painting an Extension</strong></p><p>Once our extension is initialized, it needs to run code to render to the screen. This isn’t the only time it should paint though. What if someone filters the data? That should trigger the chart to paint again with the latest data. Or what about changing a property in the property panel? That may change an important setting for the chart, thus requiring another paint.</br></br>Fortunately for us, Qlik Sense automatically keeps track of when the data for our extension changes. Whenever a property changes, or a selection is applied, Qlik Sense provides us a new layout for our Generic Object. Qlik Sense knows that since we have new information, our chart probably doesn’t match the data anymore and needs an update as well. This is when it will trigger our paint function that we defined in <em>my-table.js</em>.</p><p><strong>3. Resizing the extension</strong></p><p>Qlik Sense is a responsive tool, so the dimensions of our extension can often change while a user is consuming it. Because there is no new data for the chart, we don’t necessarily need to completely repaint in this situation. During a resize, Qlik Sense will use the existing layout and trigger our resize function that we can use to update the chart based on the latest dimensions of our chart container element. If we don’t provide a resize function, it will just re-use our paint function.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="lifecycle-of-extension"><img src="./imgs/create-extension.png" alt="" class="img-responsive create-extension"></img><img src="./imgs/paint-extension.png" alt="" class="img-responsive paint-extension"></img><img src="./imgs/resize-extension.png" alt="" class="img-responsive resize-extension"></img></div></div></div></div><div id="section-2"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h2>Defining Our Data</h2><p>So far, our <em>my-table</em> extension just prints a message to the dashboard. But as the name implies, we are after a little more than that. Our extension is going to be a table that shows a collection of dimensions and measures. This collection is calculated data; therefore, we need to define a dynamic property on our extension that will be able to evaluate and return our table data.</br></br></br>Qlik Sense has several dynamic property types that we can leverage for calculating data from Qlik’s model. When calculating dimensions and measures together, we want to use the HyperCubeDef dynamic property. A HyperCube is a type of dynamic structure in Qlik that takes a set of dimensions and measures and returns columns and rows of calculated data in a table-like format. It is useful for any chart that uses data in a flat way like this, such as bar charts, line charts, and of course, tables.</br></br></br>In order to get a HyperCube in our layout that we can use to draw table results in our extension, we need to define one in our Generic Object properties. We do this using the HyperCubeDef structure mentioned before. This definition can be very complicated to assemble, as HyperCubes have a complex set of features that make them very robust.</br></br></br>Fortunately for us, Qlik Sense ships with some re-usable components for our properties panel that makes it easy for us to get started with defining dimensions, measures, and sorting attributes for our extension. Let’s get started with adding a hypercube to our extension.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div><div id="section-3"class="section initial-properties-editor"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h3>Adding the HyperCube to our Generic Object</h3><p>The first thing we need to do is modify the initialProperties of our extension definition in <em>my-table.js</em>.</br></br></br>In the previous chapter, we created a static property on our initialProperties object for the textColor:</br></br></br>Let’s add a HyperCubeDef to this object. The full syntax for this definition can be found in <a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCubeDef.htm">Qlik’s API documentation</a>, but for now let’s just use these basic properties:</br></br></br>We started by adding a property called qHyperCubeDef. Why the “q”? Well, all dynamic properties in Qlik Sense are preceded with a “q”. So when you want to insert a HyperCubeDef, you label the property qHyperCubeDef. Qlik Sense then knows to evaluate that property dynamically.</br></br></br>Inside our qHyperCubeDef, we created  qDimensions and qMeasures properties that are set to empty arrays.  These properties hold metadata that defines the dimensions and measures that Qlik should use when calculating our layout. When our extension is first created, these will be empty since a user will not have defined them yet.</br></br></br>The last property that we added is the qInitialDataFetch. This property tells Qlik Sense how much data to pull, and where to pull it from, when evaluating our layout. This property is important because Qlik Sense has strict limits on how much data it can fetch at once. It will fetch a maximum of 10,000 cells at a time. A cell is a combination of a row position and column position; in our example, we’ve told Qlik Sense that we will have up to 10 columns (the qWidth property) and 1,000 rows (the qHeight property). At most, these settings could produce qWidth * qHeight cells, which equals 10,000.</br></br></br>qTop and qLeft tells Qlik Sense which row and column to start at, respectively, as it calculates data. For our default data fetch, we will start at the top. These settings are useful if you want to stream data from other positions in the HyperCube. This comes in handy when using larger data sets, which we cover in chapter 108.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="initial-properties-editor"></div></div></div></div><div id="section-4"class="section convert-extension"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h3>Adding Data to the HyperCube</h3><p>With these initial properties in place, our extension object will now have a hypercube on it going forward. Note that our previous version of the extension did not have this initial property, so it will be missing the hypercube unless we re-create the extension on our dashboard. One easy way to do that is to drag and drop a new version of the extension from the Custom Objects panel onto the old instance of it on our sheet and select the “Convert to…” option. This action will re-initialize the extension using the latest code, which will include our new HyperCube property.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="convert-extension"><img src="./imgs/convert-extension.gif" alt="" class="img-responsive convert-extension"></img></div></div></div></div><div id="section-5"class="section definition-editor"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>It’s great that we have a HyperCube on our extension, but its not very useful to us yet because it has no dimensions or measures defined. We want our users to easily add dimensions and measures through the Qlik Sense properties panel like they do in other charts. Qlik Sense provides an easy way to do this with some re-usable components for our properties panel. Specifically, we are going to add components for:</p><ul><li><p>adding and removing dimensions</p></li><li><p>adding and removing measures</p></li><li><p>sorting the HyperCube</br></br></br></p></li></ul><p>Let’s start with adding a dimension. We can add a dimension component to our properties panel by editing our definition from before like so:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="definition-editor"></div></div></div></div><div id="section-6"class="section add-dimension"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>With this definition in place, our properties panel will now have a section called <em>Dimensions</em> where users can add, configure, and remove dimensions just like they would in other Qlik Sense charts. We also added the min and max properties to put some constraints around how many dimensions can be added. In this case, our user can add between 1 and 5 dimensions for the chart to work. If a dimension isn’t defined, our extension will display a message asking the user to add a dimension.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="add-dimension"><img src="./imgs/add-dimension.png" alt="" class="img-responsive add-dimension"></img></div></div></div></div><div id="section-7"class="section definition-editor-2"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>As you might guess, adding measures and sorting is just as straightforward. We can modify our definition to add those components in as well:</br></br></br>Now users can add, remove, and resort data in our extension using the properties panel!</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="definition-editor-2"></div></div></div></div><div id="section-8"class="section properties-panel"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h3>Parsing the Data from a Hypercube</h3><p>Our users can add data to our extension, so now we need to use that data. Let’s look at how our HyperCubeDef translates to our layout that we receive in the paint function.</br></br></br>While we define a HyperCube on our Generic Object properties using the qHyperCubeDef property, our evaluated layout will contain a property called qHyperCube instead. This qHyperCube property will contain the calculated results, of our qHyperCubeDef.</br></br></br>The qHyperCube is a complex JSON object with a lot of useful metadata. Let’s walk through the key properties it has for our extension.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="properties-panel"><img src="./imgs/panel.png" alt="" class="img-responsive panel"></img></div></div></div></div><div id="section-9"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h5>qDimensionInfo</h5><p>The qDimensionInfo property of our HyperCube contains an array of objects representing each dimension in the cube. Each of these objects has metadata about the dimension, such as the field name, number of distinct values, and label. The label is especially important to us, as we will want to match our title for the dimension to what the user entered as the label. This label is stored under the qFallbackTitle property, stored under qHyperCube/qDimensionInfo/<DIMENSION NUMBER>/qFallBackTitle</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div><div id="section-10"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h5>qMeasureInfo</h5><p>The qMeasureInfo property functions similarly to the qDimensionInfo, except that it provides metadata on the measures. This metadata varies slightly to be specific for measures. For example, the metadata objects under qMeasureInfo contain properties called qMin and qMax that list the min and max values of each measure. These properties come in handy when creating visualizations that require some scaling, like a line chart. Just like in qDimensionInfo, the property qFallbackTitle is used for measure labels. It is found at qHyperCube/qMeasureInfo/<MEASURE NUMBER>/qFallBackTitle</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div><div id="section-11"class="section data-pages"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h5>qDataPages</h5><p>The qDataPages property is where our calculated table of data resides. As its name implies, it contains groups of pages. Within each page is a property called qMatrix  which is an array of arrays that form a table structure.</p><p>Each element in the qMatrix array corresponds with 1 row of data.  If we wanted to get the 2nd row of the table, we would access it like so:</p><p>Within that 1 row, we will find an array of objects. Each one of those objects corresponds with a cell in our table. We could access the cell in the 3rd column of the 2nd cell like so:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="data-pages"><img src="./imgs/q-matrix.png" alt="" class="img-responsive q-matrix"></img><img src="./imgs/q-matrix-row.png" alt="" class="img-responsive q-matrix-row"></img><img src="./imgs/q-matrix-cell.png" alt="" class="img-responsive q-matrix-cell"></img></div></div></div></div><div id="section-12"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>Each cell is a JSON object. That object has several properties to describe the value in that cell. These properties could include:</p><ul><li><p>qText – a text representation of the cell value</p></li><li><p>qNum – a numeric representation of the cell value</p></li><li><p>qElemNumber – a rank number of the cell value. For dimensions, this corresponds with the FieldValueIndex of the dimension value, which we will use later for selections.</br></br></br></p></li></ul><p>There are other properties that you may find in a cell; to learn more, see <a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/NxCell.htm">NxCell ‒ Qlik Sense</a>.</br></br></br>Using this structure, we can easily pull out values from the calculated data. In the example above, we would get the numeric value of the cell in the 2nd row, third column of the qMatrix via layout.qHyperCube.qDataPages[0].qMatrix[2][1].qNum.</br></br></br>Tracing through those steps 1 by 1:</p><ul><li><p>First we accessed the layout.layout</p></li><li><p>Then we accessed the qHyperCube.layout.qHyperCube</p></li><li><p>Next we opened the first element of qDataPages, because we only have 1 page defined.layout.qHyperCube.qDataPages[0]</p></li><li><p>On that page, we access the qMatrix and select the 3rd row (index 2).layout.qHyperCube.qDataPages[0].qMatrix[2]</p></li><li><p>In that row, we grab the 2nd column (index 1).layout.qHyperCube.qDataPages[0].qMatrix[2][1]</p></li><li><p>Finally, we grab the numeric representation of the value.layout.qHyperCube.qDataPages[0].qMatrix[2][1].qNum</p></li></ul></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div><div id="section-13"class="section paint-editor"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h3>Rendering Data from the HyperCube</h3><p>Now that we know how to access our data, let’s use our paint function to draw a table to the screen.  Our existing paint function printed a hello world message to the screen. Let’s clear that out and start with just resetting our html:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor"></div></div></div></div><div id="section-14"class="section paint-editor-2"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>In order to create a table, we will want to do two things: create a header row with our dimension and measure labels, and create table rows for each row in our qMatrix. Let’s start by creating a table and a header row.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-2"></div></div></div></div><div id="section-15"class="section paint-editor-3"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>For each dimension and measure, we need to add a header cell to the header row with the correct label. We can iterate through our qDimensionInfo and qMeasureInfo arrays to create cells and add the labels from the qFallbackTitle property:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-3"></div></div></div></div><div id="section-16"class="section headers"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>Now our extension should show a nice header row.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="headers"><img src="./imgs/headers.png" alt="" class="img-responsive headers"></img></div></div></div></div><div id="section-17"class="section paint-editor-4"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>Let’s add the rest of the data. We know the data resides in the qMatrix in an array of arrays, where the outer array is a row and the inner arrays are cells within that row for each column. We can map through each row of the qMatrix and create a table row, then map through each cell in the row and create a cell with the value from that cell.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-4"></div></div></div></div><div id="section-18"class="section ext-table"><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <p>Our extension now takes in dimensions and measures, and renders the resulting combination of data to a table on our dashboard!</br></br></br>Our extension doesn’t look great right now – we will come back to style it later. For now though, add some measures and play with their number formatting in the properties panel. Notice how the text values in our cell match the number format we specify for measures.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="ext-table"><img src="./imgs/ext-table.png" alt="" class="img-responsive ext-table"></img></div></div></div></div><div id="section-19"class="section "><div class="row">
          <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
    <h2>Fin</h2><h4>Recap</h4><ul><li><p>Extensions run their extension.js code that defines the extension once upon instantiation, then subsequently run paint and resize functions multiple times as the data is filtered, the chart changed, or the page resized</p></li><li><p>HyperCubes are a dynamic data structure in Qlik for defining tables of data based on dimensions and measures</p></li><li><p>The calculated results of a HyperCube are found in the qMatrix, which is a table stored in the format of an array of rows, which are arrays of cells.</p></li></ul><h4>Resources</h4><ul><li><p><a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCubeDef.htm">HyperCubeDef Documentation</a></p></li><li><p><a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCube.htm">HyperCube Documentation</a></p></li></ul><h4>Troubleshooting Guide</h4><ul><li></li></ul></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph"></div></div></div></div>