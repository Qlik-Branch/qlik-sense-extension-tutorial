# 108. Make it Scalable
Learning goal: Review strategies for using larger volumes of data within an extension
</br>
[Chapter 108 complete code](https://github.com/axisgroup/my-table/tree/108-make-it-scalable)

<div class="graph"></div>

In chapter 102, we discussed configuring our HyperCubeDef with a <code>qInitialDataFetch</code> property that limited how many rows and columns our layout would pull. Qlik Sense limits us to 10,000 cells per data page, which is why we set our previous initial data fetch to 10 columns and 1,000 rows. What if we have more data than that though? 
</br>
</br>

The answer is that we can have Qlik Sense calculate multiple pages of data for us. So if we have 2,500 rows that we want to pull from the previous example, we could ask for a page of the first 1,000 records, a page for the next 1,000 records, and then a page for the last 500 records. Pages are defined in the JSON format we saw before:
* qTop: the row to start at
* qLeft: the column to start at
* qWidth: number of columns
* qHeight: number of rows

<div id="definition-editor" class="graph"></div>

We can write out the page definitions for our previous example of 2,500 rows like so:
</br>
</br>

How do we get these pages though? In our <code>my-table</code> extension, we rely on the initial data fetch property to populate our layout with this data each time. If we want to pull data pages ourselves, [we can use the Backend API’s getData method/](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/BackendAPI/getdata-method.htm). This method accepts an array of page definitions and will return a Promise for the resulting qMatrices. Note that this call still has the 10,000 cell limit, so we can’t just pass all of our pages to it at once. We will need to make the call multiple times if we want to exceed 10,000 cells.
</br>
</br>

Generally, there are 3 approaches to exceeding the cell limit:
1. Using paging or scrolling to fetch additional data on demand, replacing the current data in view
	1. Pro: We only render as much data as is needed at any given time, improving performance in the browser which doesn’t work well with large data sets
	2. Con: We may want to see all of the data as part of our visualization
2. Run multiple <code>getData</code> calls in parallel and render when all the results are complete
	1. Pro: We get all of the data back as fast as possible
	2. Con: Running all of those calls in parallel can be hard for Qlik to process and produce a bottleneck, impacting response times of the Engine
3. Run multiple <code>getData</code> calls in sequence and render either when as the data comes back or when all the data is complete
	1. Pro: We get all of the data back
	2. Con: It may take longer to finish since the data fetching calls are staggered
</br>
</br>

We recommend approach 1 over the others when possible because it has the least impact on performance. Let’s walk through an example implementation with our extension. We will be making substantial changes to the /paint.js/ file. In order to better follow along, consider referencing [this GitHub comparison](https://github.com/axisgroup/my-table/compare/107-make-it-universal...108-make-it-scalable?expand=1) between the code from Chapter 107 and the code in this chapter.

<div class="graph"></div>

## Paging the Data
If our table exceeds 1,000 rows, it will cut off values. When this happens, let’s add paging buttons to the extension that will allow us to go from page to page. If I have 2,500 records for example, I will get 3 buttons - 1 for Page 1 (rows 0 - 999), 1 for Page 2 (rows 1,000 - 1,999), and 1 for Page 3 (rows 2,000 - 2,499). When I click a page button, the extension will fetch the data for that page and update the table.

<div id="paint-editor" class="graph"></div>

### Create <thead> and <tbody> elements
Currently, our extension just appends rows directly onto our table. However, we are going to be changing out the rows in the body of the table on the fly. Therefore, we need to separate the table rows into groups based on header and body rows so that we can easily add and remove elements from the right place. First, let’s add the <code>thead</code> and <code>tbody</code> elements:

<div id="paint-editor-2" class="graph"></div>

Next, let’s update all code that added rows directly to the table. Instead of appending to the table, let’s append header rows to <code>thead</code> and body rows to <code>tbody</code:

<div id="paint-editor-3" class="graph"></div>

### Create a separate function for rendering the table body rows
Since we will be rendering the table body rows based on different sets of data when users click, we need to break out that section of code into it’s own function that can be run multiple times. We will give this function an input for the <code>qMatrix</code> that should be rendered. It will also clear out the <code>tbody</code> before adding new rows to it. Let's define the render function at the bottom of our /paint.js/ file. 

<div id="paint-editor-4" class="graph"></div>

### Create buttons that page based on the number of rows
We can calculate how many pages we need based on dividing the total number of rows in our hypercube by the max page size and then rounding up to cover all rows. For example, if we have 2,500 rows and a page size of 1,000, we will need (2500 / 1000 = 2.5, rounded up) -> 3 pages. We can create a function that will fetch the right page as well as style the paged button blue on click. Finally, we can create all of the necessary buttons, name them, style them, and give them the click event handlers.
</br>
</br>

We also need to make our container scroll vertically, since we will be adding more rows than can be rendered on the page.

<div id="paint-editor-5" class="graph"></div>

### Run an initial render for the first page
Whenever the data updates, our paint function will re-run and create a new set of page buttons and table. When that happens, we want to render the first page by default. Since our HyperCube’s <code>initialDataFetch</code> gets the first page, we can trigger this initial render like so:

<div id="style-editor-1" class="graph"></div>

### Style the Buttons
Let's add some CSS so that our paging buttons look nice.

<div id="paging-table" class="graph">![](./imgs/paging-table.png)</div>

With those code changes in place, we now can use buttons to page our extension!

<div class="graph"></div>

## Pulling All Pages in Parallel and in Sequence
While we don’t recommend pulling large sets of data at once in an extension, we will share a couple of code snippets for how it can be accomplished.

<div id="page-parallel-editor" class="graph"></div>

### Getting Pages in Parallel
If we want to pull all the pages simultaneously and then render when they have all completed, we can take advantage of a function called <code>Promise.all</code>. <code>Promise.all</code> takes in an array of Promises and returns a Promise that resolves when all of the inputted promises have resolved. It will resolve with an array that contains the result from each inputted Promise. Here is an example of using it to make 3 data page calls at once and run code once they have all completed:

<div id="page-sequence-editor" class="graph"></div>

### Getting Pages in Sequence
If we want to pull the pages 1 at a time before rendering, we have to be a little more clever. JavaScript’s reduce function works nicely for this task: we can take an array of page definitions and go through them one by one, queuing up a new <code>getData</code> call each time the old one completes. We will need to store the data off somewhere.

<div class="graph"></div>

## Fin
#### Recap
* Extensions have limits on the amount of data that can be pulled at once
* The Backend API’s <code>getData</code> function can be used to request new pages of data
* Data paging can be done in response to an event, such as a button click or a scroll

#### Resources
* [Backend API ‒ Qlik Sense](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/backend-api-reference.htm)
* [Promises in JS](https://developers.google.com/web/fundamentals/getting-started/primers/promises)
