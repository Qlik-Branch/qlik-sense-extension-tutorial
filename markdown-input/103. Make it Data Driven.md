# 103: Make it Data Driven
Learning goal: Discover how to use dynamic data calculated by the QIX Engine and create our first table
</br>
[Chapter 103 complete code](https://github.com/axisgroup/my-table/tree/103-make-it-data-driven)

<div class="graph"></div>

We’ve successfully created our first extension, but it doesn’t really do much yet because we aren’t taking advantage of the Associative Model. In order to do that, we need to hook dynamic data into our extension. Before we do that though, let’s review the lifecycle of an extension. 
</br>
</br>

## The Lifecycle of an Extension
As we saw in the previous chapter, a Qlik Sense extension is built off of several components of code. When exactly do all of these functions get triggered though? Let’s examine.

There are three events that happen in the life of an extension that involve our code:
1. Creating the extension
2. Painting the extension
3. Resizing the extension

<div id="lifecycle-of-extension" class="graph">![](./imgs/create-extension.png)![](./imgs/paint-extension.png)![](./imgs/resize-extension.png)</div>

**1. Creating an Extension** 

When we drag our extension onto a dashboard to create a new instance of it, Qlik Sense runs our _my-table.js_ file to define the extension object. It will run all of the code in that file just once and return the JSON object defining our extension. A GenericObject is created for the extension based on our <code>initialProperties</code> parameter. Our <code>definition</code> parameter is used to define our properties panel. And our <code>paint</code> and <code>resize</code> functions are ready to be called when its time to render the extension. The extension will also be created every time we open or refresh the sheet it is on.

**2. Painting an Extension**

Once our extension is initialized, it needs to run code to render to the screen. This isn’t the only time it should paint though. What if someone filters the data? That should trigger the chart to paint again with the latest data. Or what about changing a property in the property panel? That may change an important setting for the chart, thus requiring another paint.
</br>
</br>
Fortunately for us, Qlik Sense automatically keeps track of when the data for our extension changes. Whenever a property changes, or a selection is applied, Qlik Sense provides us a new layout for our Generic Object. Qlik Sense knows that since we have new information, our chart probably doesn’t match the data anymore and needs an update as well. This is when it will trigger our <code>paint</code> function that we defined in _my-table.js_. 

**3. Resizing the extension**

Qlik Sense is a responsive tool, so the dimensions of our extension can often change while a user is consuming it. Because there is no new data for the chart, we don’t necessarily need to completely repaint in this situation. During a resize, Qlik Sense will use the existing layout and trigger our <code>resize</code> function that we can use to update the chart based on the latest dimensions of our chart container element. If we don’t provide a <code>resize</code> function, it will just re-use our <code>paint</code> function.

<div class="graph"></div>

## Defining Our Data
So far, our _my-table_ extension just prints a message to the dashboard. But as the name implies, we are after a little more than that. Our extension is going to be a table that shows a collection of dimensions and measures. This collection is calculated data; therefore, we need to define a dynamic property on our extension that will be able to evaluate and return our table data.
</br>
</br>

Qlik Sense has several dynamic property types that we can leverage for calculating data from Qlik’s model. When calculating dimensions and measures together, we want to use the <code>HyperCubeDef</code> dynamic property. A <code>HyperCube</code> is a type of dynamic structure in Qlik that takes a set of dimensions and measures and returns columns and rows of calculated data in a table-like format. It is useful for any chart that uses data in a flat way like this, such as bar charts, line charts, and of course, tables.
</br>
</br>

In order to get a HyperCube in our layout that we can use to draw table results in our extension, we need to define one in our Generic Object properties. We do this using the <code>HyperCubeDef</code> structure mentioned before. This definition can be very complicated to assemble, as <code>HyperCube</code>s have a complex set of features that make them very robust. 
</br>
</br>

Fortunately for us, Qlik Sense ships with some re-usable components for our properties panel that makes it easy for us to get started with defining dimensions, measures, and sorting attributes for our extension. Let’s get started with adding a hypercube to our extension.

<div id="initial-properties-editor" class="graph"></div>

### Adding the HyperCube to our Generic Object
The first thing we need to do is modify the <code>initialProperties</code> of our extension definition in _my-table.js_. 
</br>
</br>

In the previous chapter, we created a static property on our <code>initialProperties</code> object for the textColor:
</br>
</br>

Let’s add a <code>HyperCubeDef</code> to this object. The full syntax for this definition can be found in [Qlik’s API documentation](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCubeDef.htm), but for now let’s just use these basic properties:
</br>
</br>

We started by adding a property called <code>qHyperCubeDef</code>. Why the “q”? Well, all dynamic properties in Qlik Sense are preceded with a “q”. So when you want to insert a <code>HyperCubeDef</code>, you label the property <code>qHyperCubeDef</code>. Qlik Sense then knows to evaluate that property dynamically. 
</br>
</br>

Inside our <code>qHyperCubeDef</code>, we created  <code>qDimensions</code> and <code>qMeasures</code> properties that are set to empty arrays.  These properties hold metadata that defines the dimensions and measures that Qlik should use when calculating our layout. When our extension is first created, these will be empty since a user will not have defined them yet.
</br>
</br>

The last property that we added is the <code>qInitialDataFetch</code>. This property tells Qlik Sense how much data to pull, and where to pull it from, when evaluating our layout. This property is important because Qlik Sense has strict limits on how much data it can fetch at once. It will fetch a maximum of 10,000 cells at a time. A cell is a combination of a row position and column position; in our example, we’ve told Qlik Sense that we will have up to 10 columns (the <code>qWidth</code> property) and 1,000 rows (the <code>qHeight</code> property). At most, these settings could produce qWidth * qHeight cells, which equals 10,000.
</br>
</br>

<code>qTop</code> and <code>qLeft</code> tells Qlik Sense which row and column to start at, respectively, as it calculates data. For our default data fetch, we will start at the top. These settings are useful if you want to stream data from other positions in the HyperCube. This comes in handy when using larger data sets, which we cover in chapter 108.

<div id="convert-extension" class="graph">![](./imgs/convert-extension.gif)</div>

### Adding Data to the HyperCube
With these initial properties in place, our extension object will now have a hypercube on it going forward. Note that our previous version of the extension did not have this initial property, so it will be missing the hypercube unless we re-create the extension on our dashboard. One easy way to do that is to drag and drop a new version of the extension from the Custom Objects panel onto the old instance of it on our sheet and select the “Convert to…” option. This action will re-initialize the extension using the latest code, which will include our new HyperCube property.

<div id="definition-editor" class="graph"></div>

It’s great that we have a HyperCube on our extension, but its not very useful to us yet because it has no dimensions or measures defined. We want our users to easily add dimensions and measures through the Qlik Sense properties panel like they do in other charts. Qlik Sense provides an easy way to do this with some re-usable components for our properties panel. Specifically, we are going to add components for: 

* adding and removing dimensions
* adding and removing measures
* sorting the HyperCube
</br>
</br>

Let’s start with adding a dimension. We can add a dimension component to our properties panel by editing our definition from before like so:

<div id="add-dimension" class="graph">![](./imgs/add-dimension.png)</div>

With this definition in place, our properties panel will now have a section called _Dimensions_ where users can add, configure, and remove dimensions just like they would in other Qlik Sense charts. We also added the <code>min</code> and <code>max</code> properties to put some constraints around how many dimensions can be added. In this case, our user can add between 1 and 5 dimensions for the chart to work. If a dimension isn’t defined, our extension will display a message asking the user to add a dimension.

<div id="definition-editor-2" class="graph"></div>

As you might guess, adding measures and sorting is just as straightforward. We can modify our definition to add those components in as well:
</br>
</br>

Now users can add, remove, and re-sort data in our extension using the properties panel!

<div id="properties-panel" class="graph">![](./imgs/panel.png)</div>

### Parsing the Data from a Hypercube
Our users can add data to our extension, so now we need to use that data. Let’s look at how our <code>HyperCubeDef</code> translates to our layout that we receive in the paint function.
</br>
</br>

While we define a HyperCube on our Generic Object properties using the <code>qHyperCubeDef</code> property, our evaluated layout will contain a property called <code>qHyperCube</code> instead. This <code>qHyperCube</code> property will contain the calculated results, of our <code>qHyperCubeDef</code>. 
</br>
</br>

The <code>qHyperCube</code> is a complex JSON object with a lot of useful metadata. Let’s walk through the key properties it has for our extension.

<div class="graph"></div>

##### qDimensionInfo
The <code>qDimensionInfo</code> property of our HyperCube contains an array of objects representing each dimension in the cube. Each of these objects has metadata about the dimension, such as the field name, number of distinct values, and label. The label is especially important to us, as we will want to match our title for the dimension to what the user entered as the label. This label is stored under the <code>qFallbackTitle</code> property, stored under <code>qHyperCube/qDimensionInfo/<DIMENSION NUMBER>/qFallBackTitle</code>

<div class="graph"></div>

##### qMeasureInfo
The <code>qMeasureInfo</code> property functions similarly to the <code>qDimensionInfo</code>, except that it provides metadata on the measures. This metadata varies slightly to be specific for measures. For example, the metadata objects under <code>qMeasureInfo</code> contain properties called <code>qMin</code> and <code>qMax</code> that list the min and max values of each measure. These properties come in handy when creating visualizations that require some scaling, like a line chart. Just like in <code>qDimensionInfo</code>, the property <code>qFallbackTitle</code> is used for measure labels. It is found at <code>qHyperCube/qMeasureInfo/<MEASURE NUMBER>/qFallBackTitle</code>

<div id="data-pages" class="graph">![](./imgs/q-matrix.png)![](./imgs/q-matrix-row.png)![](./imgs/q-matrix-cell.png)</div>

##### qDataPages
The **qDataPages** property is where our calculated table of data resides. As its name implies, it contains groups of pages. Within each page is a property called **qMatrix**  which is an array of arrays that form a table structure.

Each element in the **qMatrix** array corresponds with 1 row of data.  If we wanted to get the 2nd row of the table, we would access it like so:

Within that 1 row, we will find an array of objects. Each one of those objects corresponds with a cell in our table. We could access the cell in the 3rd column of the 2nd cell like so:

<div class="graph"></div>

Each cell is a JSON object. That object has several properties to describe the value in that cell. These properties could include:
* qText – a text representation of the cell value
* qNum – a numeric representation of the cell value
* qElemNumber – a rank number of the cell value. For dimensions, this corresponds with the FieldValueIndex of the dimension value, which we will use later for selections.
</br>
</br>

There are other properties that you may find in a cell; to learn more, see [NxCell ‒ Qlik Sense](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/NxCell.htm).
</br>
</br>

Using this structure, we can easily pull out values from the calculated data. In the example above, we would get the numeric value of the cell in the 2nd row, third column of the qMatrix via <code>layout.qHyperCube.qDataPages&#91;0&#93;.qMatrix&#91;2&#93;&#91;1&#93;.qNum</code>.
</br>
</br>

Tracing through those steps 1 by 1:
* First we accessed the layout.
<code>layout</code>
* Then we accessed the qHyperCube.
<code>layout.qHyperCube</code>
* Next we opened the first element of qDataPages, because we only have 1 page defined.
<code>layout.qHyperCube.qDataPages&#91;0&#93;</code>
* On that page, we access the qMatrix and select the 3rd row (index 2).
<code>layout.qHyperCube.qDataPages&#91;0&#93;.qMatrix&#91;2&#93;</code>
* In that row, we grab the 2nd column (index 1).
<code>layout.qHyperCube.qDataPages&#91;0&#93;.qMatrix&#91;2&#93;&#91;1&#93;</code>
* Finally, we grab the numeric representation of the value.
<code>layout.qHyperCube.qDataPages&#91;0&#93;.qMatrix&#91;2&#93;&#91;1&#93;.qNum</code>

<div id="paint-editor" class="graph"></div>

### Rendering Data from the HyperCube
Now that we know how to access our data, let’s use our paint function to draw a table to the screen.  Our existing paint function printed a hello world message to the screen. Let’s clear that out and start with just resetting our html:

<div id="paint-editor-2" class="graph"></div>

In order to create a table, we will want to do two things: create a header row with our dimension and measure labels, and create table rows for each row in our <code>qMatrix</code>. Let’s start by creating a table and a header row.

<div id="paint-editor-3" class="graph"></div>

For each dimension and measure, we need to add a header cell to the header row with the correct label. We can iterate through our <code>qDimensionInfo</code> and <code>qMeasureInfo</code> arrays to create cells and add the labels from the <code>qFallbackTitle</code> property:

<div id="headers" class="graph">![](./imgs/headers.png)</div>

Now our extension should show a nice header row.

<div id="paint-editor-4" class="graph"></div>

Let’s add the rest of the data. We know the data resides in the <code>qMatrix</code> in an array of arrays, where the outer array is a row and the inner arrays are cells within that row for each column. We can map through each row of the qMatrix and create a table row, then map through each cell in the row and create a cell with the value from that cell. 

<div id="ext-table" class="graph">![](./imgs/ext-table.png)</div>

Our extension now takes in dimensions and measures, and renders the resulting combination of data to a table on our dashboard!
</br>
</br>

Our extension doesn’t look great right now – we will come back to style it later. For now though, add some measures and play with their number formatting in the properties panel. Notice how the text values in our cell match the number format we specify for measures.

<div class="graph"></div>

## Fin
#### Recap
* Extensions run their <code>extension.js</code> code that defines the extension once upon instantiation, then subsequently run paint and resize functions multiple times as the data is filtered, the chart changed, or the page resized
* HyperCubes are a dynamic data structure in Qlik for defining tables of data based on dimensions and measures
* The calculated results of a HyperCube are found in the qMatrix, which is a table stored in the format of an array of rows, which are arrays of cells.

#### Resources
* [HyperCubeDef Documentation](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCubeDef.htm)
* [HyperCube Documentation](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/EngineAPI/Content/Structs/HyperCube.htm)
