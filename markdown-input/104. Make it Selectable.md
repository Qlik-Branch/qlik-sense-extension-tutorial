# 104. Make it Selectable
Learning goal: Make our extension interactive by incorporating selections with the Backend API
</br>
[Chapter 104 complete code](https://github.com/axisgroup/my-table/tree/104-make-it-selectable)

<div class="graph"></div>

We’ve now got an extension that renders data from Qlik. That is only one piece of the puzzle however. It’s unidirectional: we receive data from Qlik that we render. But we also want our extension to be able to go the opposite direction. That is to say, we want to be able to filter data in Qlik by interacting with our extension. Let’s work on this feature next. 

<div id="field-indices" class="graph">![](./imgs/field-indices.png)</div>

In the previous chapter, we did a deep-dive on the <code>qMatrix</code> structure that contains our calculated data in HyperCubes. Specifically, we looked at the individual cells in our row and column structure and examined properties like <code>qNum</code> and <code>qText</code>. One special property we discussed was the <code>qElemNumber</code>. When looking at a dimension cell, the <code>qElemNumber</code> represents the Field Index of a dimension value within a dimension. The <code>Field Index</code> is Qlik’s unique identifier for a distinct value in a Field. This index is important to us because it can be used to tell Qlik exactly which values we want to filter in a dimension.
</br>
</br>

In order to leverage our <code>qElemNumbers</code> to make selections, we need an API to talk to Qlik. Enter the **Backend API**.

<div class="graph"></div>

### The Backend API
The BackendAPI is an API unique to extensions that enables us to communicate with the Qlik engine. It provides some Helper functions for common calls that we might want to make in our extension. For example, the Backend API has a <code>getProperties</code> method that will retrieve our Generic Object properties. [For more on the Backend API, check out the documentation.](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/backend-api-reference.htm)
</br>
</br>

One key function in the Backend API is the <code>selectValues</code> method. This method can filter data in a dimension that exists in our HyperCube. It takes 3 inputs:

1. A number for the index of our dimension. The first dimension in our HyperCube would be index <code>0</code>.
2. An array of <code>qElemNumbers</code> to select. All values entered here will be part of the new selection.
3. A boolean for the toggle mode of our selection. When true, the selected values will be added to any already selected values. When false, any already selected values will be discarded before selecting the new list of values.

<div id="select-values-api" class="graph"></div>

Let’s take the following example table from a HyperCube, with annotated Field Indices:

Let’s say I want to select "Manufacturing" and "Contractor" from my "Department" dimension. Since that dimension is in the first column, I could use the method <code>selectValues(0, &#91;0, 1&#93;, false)</code>

pre-selection

post-selection

This call ensures that I filter to only the field values with indices 0 and 1.

If I want to add more selections on top, I could make the call again and set the toggle mode to true: <code>selectValues(0, &#91;4&#93;, true)</code>

Alternatively, I could have set toggle mode to false, which would deselect elements 1 and 3 and then select element 4: <code>selectValues(0, &#91;3&#93;, false)</code>

<div class="graph"></div>

### Adding Selections to Our Table
Now that we know how to use the <code>selectValues</code> method, we can incorporate it into our extension. Let’s add a feature where a user can click on a dimension value to filter to that dimension.

<div id="paint-editor" class="graph"></div>

First, we are going to need to access the Backend API in our extension code. In our paint method, we can access the Backend API via <code>this.backendApi</code>. Let’s go ahead and save off that reference for later use:

<div id="paint-editor-2" class="graph"></div>

In order to make our cells selectable, we need to tag them with the right metadata that we can use to feed a <code>selectValues</code> call. Let’s start by editing our code where we create table cells to determine if they are dimension cells or not. We can do this by comparing the column number to our <code>dimensionInfo</code> array length.

<div id="paint-editor-3" class="graph"></div>

Inside of our new if statement, we can add the metadata we want to the table cell. For our purposes, let’s tag it with a class called <code>selectable</code> that we can use to find the selectable cells later. Let’s also add attributes for the dimension column number and the field index.

<div id="paint-editor-4" class="graph"></div>

Almost there! We now have td’s that should be selectable, easily identified by a <code>.selectable</code> class. We also have metadata about the dimension column and the value’s Field Index. Now we just need to create a UI for selection. We can do that by adding a click event to these elements that calls <code>selectValues</code>. Let’s add this at the end after our $element has been populated with the table:

<div id="extension-selection" class="graph">![](./imgs/extension-selection.gif)</div>

Now we have an interactive extension that can filter data in our Qlik Sense dashboards!

<div class="graph"></div>

## Fin
#### Recap
* Extensions can interact with the QIX Engine via the <code>Backend API</code> to add functionality like making selections.

#### Resources
* [Backend API Documentation](http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/backend-api-reference.htm)
