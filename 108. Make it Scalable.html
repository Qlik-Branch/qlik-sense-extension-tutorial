<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Make it Scalable</title>
    <link href="bootstrap/dist/css/bootstrap.css" rel="stylesheet">
  <link href="p8.css" rel="stylesheet"><link href="app.css" rel="stylesheet"></head>
  <body>
    <!--<div id="sidebar" class="sidebar">
  <div class="sidebar-label">Qlik Extension Tutorial</div>
  <div><a href="javascript:void(0)" class="closebtn">&times;</a></div>
  </br>
  </br>
  <hr/>
  <ul class="nav nav-sidebar">
    <li class="chapter-0"><a href="100. Prereq Qliks Open Ecosystem.html"><span class="glyphicon glyphicon-menu-right"></span> 100. Qlik's open ecosystem</a>
      <ul class="nav sub-sidebar sublist-0">
        <li><a href="#h2-0">Meet the Qlik Sense client</a></li>
        <li><a href="#h2-1">Qlik Sense under the hood</a></li>
        <li><a href="#h2-2">The open ecosystem</a></li>
        <li><a href="#h2-3">Why an open ecosystem?</a></li>
        <li><a href="#h2-4">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-1"><a href="101. What Are Extensions.html"><span class="glyphicon glyphicon-menu-right"></span> 101. What are extensions</a>
      <ul class="nav sub-sidebar sublist-1">
        <li><a href="#h2-0">What are extensions conceptually?</a></li>
        <li><a href="#h2-1">What are extensions technically?</a></li>
        <li><a href="#h2-2">How do you deploy an extension?</a></li>
        <li><a href="#h2-3">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-2"><a href="102. Hello World.html"><span class="glyphicon glyphicon-menu-right"></span> 102. Hello World</a>
      <ul class="nav sub-sidebar sublist-2">
        <li><a href="#h2-0">Prerequisites</a></li>
        <li><a href="#h2-1">Anatomy of an extension</a></li>
        <li><a href="#h2-2">Setting up development environment</a></li>
        <li><a href="#h2-3">Wiring it together with code</a></li>
        <li><a href="#h2-4">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-3"><a href="103. Make it Data Driven.html"><span class="glyphicon glyphicon-menu-right"></span> 103. Make it data driven</a>
      <ul class="nav sub-sidebar sublist-3">
        <li><a href="#h2-0">Lifecycle of an Extension</a></li>
        <li><a href="#h2-1">Defining Our Data</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-4"><a href="104. Make it Selectable.html"><span class="glyphicon glyphicon-menu-right"></span> 104. Make it selectable</a>
      <ul class="nav sub-sidebar sublist-4">
        <li><a href="#h2-0">The backend API</a></li>
        <li><a href="#h2-1">Adding selections to our table</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-5"><a href="105. Make it Stylish.html"><span class="glyphicon glyphicon-menu-right"></span> 105. Make it stylish</a>
      <ul class="nav sub-sidebar sublist-5">
        <li><a href="#h2-0">Creating a stylesheet</a></li>
        <li><a href="#h2-1">Module loading</a></li>
        <li><a href="#h2-2">Keep it modular</a></li>
        <li><a href="#h2-3">Adding custom property panel items</a></li>
        <li><a href="#h2-4">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-6"><a href="106. Make it Responsive.html"><span class="glyphicon glyphicon-menu-right"></span> 106. Make it responsive</a>
      <ul class="nav sub-sidebar sublist-6">
        <li><a href="#h2-0">Adding responsiveness via CSS</a></li>
        <li><a href="#h2-1">Adding responsiveness via JS</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-7"><a href="107. Make it Universal.html"><span class="glyphicon glyphicon-menu-right"></span> 107. Make it universal</a>
      <ul class="nav sub-sidebar sublist-7">
        <li><a href="#h2-0">Environment Context</a></li>
        <li><a href="#h2-1">Printing Extensions</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
    <li class="chapter-8"><a href="108. Make it Scalable.html"><span class="glyphicon glyphicon-menu-right"></span> 108. Make it scalable</a>
      <ul class="nav sub-sidebar sublist-8">
        <li><a href="#h2-0">Paging the Data</a></li>
        <li><a href="#h2-1">Pulling All Pages in Parallel and in Sequence</a></li>
        <li><a href="#h2-2">Fin</a></li>
      </ul>
    </li>
  </ul>
</div>-->

    <div class="hamburger-open">&#9776;</div>

    <div class="main-content">
      <div class="container content">
        <div class="header">
          <h1>108. Make it Scalable</h1><p>Learning goal: Review strategies for using larger volumes of data within an extension</br><a href="https://github.com/axisgroup/my-table/tree/108-make-it-scalable" target="_blank">Chapter 108 complete code</a></p>
          <hr/>
        </div>
        <div id="body-content">
          <div id="section-0"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <p>In chapter 102, we discussed configuring our HyperCubeDef with a <code>qInitialDataFetch</code> property that limited how many rows and columns our layout would pull. Qlik Sense limits us to 10,000 cells per data page, which is why we set our previous initial data fetch to 10 columns and 1,000 rows. What if we have more data than that though?</br></br></p><p>The answer is that we can have Qlik Sense calculate multiple pages of data for us. So if we have 2,500 rows that we want to pull from the previous example, we could ask for a page of the first 1,000 records, a page for the next 1,000 records, and then a page for the last 500 records. Pages are defined in the JSON format we saw before:</p><ul><li><p>qTop: the row to start at</p></li><li><p>qLeft: the column to start at</p></li><li><p>qWidth: number of columns</p></li><li><p>qHeight: number of rows</p></li></ul></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-1"class="section definition-editor"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>We can write out the page definitions for our previous example of 2,500 rows like so:</br></br></p><p>How do we get these pages though? In our <code>my-table</code> extension, we rely on the initial data fetch property to populate our layout with this data each time. If we want to pull data pages ourselves, <a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/BackendAPI/getdata-method.htm" target="_blank">we can use the Backend API’s getData method/</a>. This method accepts an array of page definitions and will return a Promise for the resulting qMatrices. Note that this call still has the 10,000 cell limit, so we can’t just pass all of our pages to it at once. We will need to make the call multiple times if we want to exceed 10,000 cells.</br></br></p><p>Generally, there are 3 approaches to exceeding the cell limit:</p><ol><li><p>Using paging or scrolling to fetch additional data on demand, replacing the current data in view</p><ol><li><p>Pro: We only render as much data as is needed at any given time, improving performance in the browser which doesn’t work well with large data sets</p></li><li><p>Con: We may want to see all of the data as part of our visualization</p></li></ol></li><li><p>Run multiple <code>getData</code> calls in parallel and render when all the results are complete</p><ol><li><p>Pro: We get all of the data back as fast as possible</p></li><li><p>Con: Running all of those calls in parallel can be hard for Qlik to process and produce a bottleneck, impacting response times of the Engine</p></li></ol></li><li><p>Run multiple <code>getData</code> calls in sequence and render either when as the data comes back or when all the data is complete</p><ol><li><p>Pro: We get all of the data back</p></li><li><p>Con: It may take longer to finish since the data fetching calls are staggered</br></br></p></li></ol></li></ol><p>We recommend approach 1 over the others when possible because it has the least impact on performance. Let’s walk through an example implementation with our extension. We will be making substantial changes to the /paint.js/ file. In order to better follow along, consider referencing <a href="https://github.com/axisgroup/my-table/compare/107-make-it-universal...108-make-it-scalable?expand=1" target="_blank">this GitHub comparison</a> between the code from Chapter 107 and the code in this chapter.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="definition-editor"></div></div></div></div><div id="section-2"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Paging the Data</h2><p>If our table exceeds 1,000 rows, it will cut off values. When this happens, let’s add paging buttons to the extension that will allow us to go from page to page. If I have 2,500 records for example, I will get 3 buttons - 1 for Page 1 (rows 0 - 999), 1 for Page 2 (rows 1,000 - 1,999), and 1 for Page 3 (rows 2,000 - 2,499). When I click a page button, the extension will fetch the data for that page and update the table.</p></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-3"class="section paint-editor"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Create <thead> and <tbody> elements</h3><p>Currently, our extension just appends rows directly onto our table. However, we are going to be changing out the rows in the body of the table on the fly. Therefore, we need to separate the table rows into groups based on header and body rows so that we can easily add and remove elements from the right place. First, let’s add the <code>thead</code> and <code>tbody</code> elements:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor"></div></div></div></div><div id="section-4"class="section paint-editor-2"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>Next, let’s update all code that added rows directly to the table. Instead of appending to the table, let’s append header rows to <code>thead</code> and body rows to <code>tbody</code:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-2"></div></div></div></div><div id="section-5"class="section paint-editor-3"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Create a separate function for rendering the table body rows</h3><p>Since we will be rendering the table body rows based on different sets of data when users click, we need to break out that section of code into it’s own function that can be run multiple times. We will give this function an input for the <code>qMatrix</code> that should be rendered. It will also clear out the <code>tbody</code> before adding new rows to it. Let's define the render function at the bottom of our /paint.js/ file.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-3"></div></div></div></div><div id="section-6"class="section paint-editor-4"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Create buttons that page based on the number of rows</h3><p>We can calculate how many pages we need based on dividing the total number of rows in our hypercube by the max page size and then rounding up to cover all rows. For example, if we have 2,500 rows and a page size of 1,000, we will need (2500 / 1000 = 2.5, rounded up) -> 3 pages. We can create a function that will fetch the right page as well as style the paged button blue on click. Finally, we can create all of the necessary buttons, name them, style them, and give them the click event handlers.</br></br></p><p>We also need to make our container scroll vertically, since we will be adding more rows than can be rendered on the page.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-4"></div></div></div></div><div id="section-7"class="section paint-editor-5"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Run an initial render for the first page</h3><p>Whenever the data updates, our paint function will re-run and create a new set of page buttons and table. When that happens, we want to render the first page by default. Since our HyperCube’s <code>initialDataFetch</code> gets the first page, we can trigger this initial render like so:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paint-editor-5"></div></div></div></div><div id="section-8"class="section style-editor-1"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Style the Buttons</h3><p>Let's add some CSS so that our paging buttons look nice.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="style-editor-1"></div></div></div></div><div id="section-9"class="section paging-table"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <p>With those code changes in place, we now can use buttons to page our extension!</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="paging-table"><img src="./images/paging-table.png" alt="" class="img-responsive"></img></div></div></div></div><div id="section-10"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Pulling All Pages in Parallel and in Sequence</h2><p>While we don’t recommend pulling large sets of data at once in an extension, we will share a couple of code snippets for how it can be accomplished.</p></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div><div id="section-11"class="section page-parallel-editor"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Getting Pages in Parallel</h3><p>If we want to pull all the pages simultaneously and then render when they have all completed, we can take advantage of a function called <code>Promise.all</code>. <code>Promise.all</code> takes in an array of Promises and returns a Promise that resolves when all of the inputted promises have resolved. It will resolve with an array that contains the result from each inputted Promise. Here is an example of using it to make 3 data page calls at once and run code once they have all completed:</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="page-parallel-editor"></div></div></div></div><div id="section-12"class="section page-sequence-editor"><div class="row">
              <div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-left">
        <h3>Getting Pages in Sequence</h3><p>If we want to pull the pages 1 at a time before rendering, we have to be a little more clever. JavaScript’s reduce function works nicely for this task: we can take an array of page definitions and go through them one by one, queuing up a new <code>getData</code> call each time the old one completes. We will need to store the data off somewhere.</p></div><div class="col-xs-6 col-sm-6 col-md-6 col-lg-6 body-right"><div class="graph" id="page-sequence-editor"></div></div></div></div><div id="section-13"class="section "><div class="row">
              <div class="col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 body-left">
        <h2>Fin</h2><h4>Recap</h4><ul><li><p>Extensions have limits on the amount of data that can be pulled at once</p></li><li><p>The Backend API’s <code>getData</code> function can be used to request new pages of data</p></li><li><p>Data paging can be done in response to an event, such as a button click or a scroll</p></li></ul><h4>Resources</h4><ul><li><p><a href="http://help.qlik.com/en-US/sense-developer/3.2/Subsystems/APIs/Content/backend-api-reference.htm" target="_blank">Backend API ‒ Qlik Sense</a></p></li><li><p><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" target="_blank">Promises in JS</a></p></li></ul></div><div class="col-xs-0 col-sm-0 col-md-0 col-lg-0 body-right"><div class="graph"></div></div></div></div>
        </div>
        <hr/>
      </div>
    </div>

    <script src="jquery.min.js"></script>
    <script src="bootstrap/dist/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="p8.bundle.js"></script><script type="text/javascript" src="app.bundle.js"></script></body>
</html>